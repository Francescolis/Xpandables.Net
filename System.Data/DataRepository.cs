/*******************************************************************************
 * Copyright (C) 2025 Kamersoft
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
********************************************************************************/
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Runtime.CompilerServices;

namespace System.Data;

/// <summary>
/// Provides an ADO.NET implementation of <see cref="IDataRepository{Tdata}"/>.
/// </summary>
/// <remarks>
/// <para>
/// This implementation uses <see cref="IDataSqlBuilder"/> to generate SQL queries from
/// <see cref="IDataSpecification{Tdata, TResult}"/> and executes them using ADO.NET.
/// </para>
/// <para>
/// All operations are executed immediately against the database. For transactional
/// operations, use the repository within an <see cref="IDataUnitOfWork"/> with an active transaction.
/// </para>
/// </remarks>
/// <typeparam name="TData">The data type.</typeparam>
/// <remarks>
/// Initializes a new instance of the <see cref="DataRepository{Tdata}"/> class.
/// </remarks>
/// <param name="connectionScope">The connection scope to use for database operations.</param>
/// <param name="sqlBuilder">The SQL builder for generating queries.</param>
/// <param name="sqlMapper">The SQL mapper for mapping results.</param>
/// <param name="interceptor">The optional command interceptor for logging and telemetry.
/// When <see langword="null"/>, <see cref="DataCommandInterceptor.Default"/> is used.</param>
#pragma warning disable CA1063 // Implement IDisposable correctly - simplified for sealed-like behavior
#pragma warning disable CA2100 // Review SQL queries for security vulnerabilities - SQL is generated by ISqlBuilder with parameters
[RequiresDynamicCode("Expression compilation requires dynamic code generation.")]
public class DataRepository<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)] TData>(
    IDataDbConnectionScope connectionScope, IDataSqlBuilder sqlBuilder, IDataSqlMapper sqlMapper,
    IDataCommandInterceptor? interceptor = null)
    : IDataRepository<TData>
    where TData : class
{
    private static readonly string _entityTypeName = typeof(TData).Name;

    [SuppressMessage("Usage", "CA2213:Disposable fields should be disposed", Justification = "")]
    private readonly IDataDbConnectionScope _connectionScope = connectionScope ?? throw new ArgumentNullException(nameof(connectionScope));
    private readonly IDataSqlBuilder _sqlBuilder = sqlBuilder ?? throw new ArgumentNullException(nameof(sqlBuilder));
    private readonly IDataSqlMapper _sqlMapper = sqlMapper ?? throw new ArgumentNullException(nameof(sqlMapper));
    private readonly IDataCommandInterceptor _interceptor = interceptor ?? DataCommandInterceptor.Default;
    private bool _isDisposed;

    /// <inheritdoc />
    [UnconditionalSuppressMessage("Trimming", "IL2091:Target generic argument does not have matching annotations",
        Justification = "TResult is expected to have public properties and parameterless constructor for mapping.")]
    public virtual async IAsyncEnumerable<TResult> QueryAsync<TResult>(
        IDataSpecification<TData, TResult> specification,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        ArgumentNullException.ThrowIfNull(specification);

        var queryResult = _sqlBuilder.BuildSelect(specification);
        var context = new DataCommandContext(queryResult.Sql, queryResult.Parameters, DataCommandOperationType.Reader, _entityTypeName);

        var command = _connectionScope.CreateCommand(queryResult);
        await using (command.ConfigureAwait(false))
        {
            var reader = await ExecuteReaderInterceptedAsync(command, context, cancellationToken)
                .ConfigureAwait(false);

            await using (reader.ConfigureAwait(false))
            {
                while (await reader.ReadAsync(cancellationToken).ConfigureAwait(false))
                {
                    yield return _sqlMapper.MapToResult(specification, reader);
                }
            }
        }
    }

    /// <inheritdoc/>
    [SuppressMessage("Trimming", "IL2091:Target generic argument does not satisfy 'DynamicallyAccessedMembersAttribute' in target method or type. The generic parameter of the source method or type does not have matching annotations.", Justification = "<Pending>")]
    public virtual IAsyncPagedEnumerable<TResult> QueryPagedAsync<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties | DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)] TResult>(
        IDataSpecification<TData, TResult> specification,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        ArgumentNullException.ThrowIfNull(specification);

        var selectResult = _sqlBuilder.BuildSelect(specification);
        var countResult = _sqlBuilder.BuildCount(specification);
        var paginationTcs = new TaskCompletionSource<int>(TaskCreationOptions.RunContinuationsAsynchronously);

        async IAsyncEnumerable<TResult> ReadPagedAsync([EnumeratorCancellation] CancellationToken ct = default)
        {
            var command = _connectionScope.CreateCommand();
            command.CommandText = $"{selectResult.Sql};{countResult.Sql}";

            var mergedParams = MergeParameters(selectResult.Parameters, countResult.Parameters);
            foreach (var param in mergedParams)
            {
                var dbParam = command.CreateParameter();
                dbParam.ParameterName = param.Name;
                dbParam.Value = param.Value ?? DBNull.Value;
                command.Parameters.Add(dbParam);
            }

            var pagedContext = new DataCommandContext(command.CommandText, [.. mergedParams], DataCommandOperationType.Reader, _entityTypeName);

            await using (command.ConfigureAwait(false))
            {
                var reader = await ExecuteReaderInterceptedAsync(command, pagedContext, ct).ConfigureAwait(false);
                await using (reader.ConfigureAwait(false))
                {
                    try
                    {
                        while (await reader.ReadAsync(ct).ConfigureAwait(false))
                        {
                            yield return _sqlMapper.MapToResult<TResult>(reader);
                        }

                        if (await reader.NextResultAsync(ct).ConfigureAwait(false) &&
                            await reader.ReadAsync(ct).ConfigureAwait(false))
                        {
                            var totalCount = Convert.ToInt64(reader.GetValue(0), CultureInfo.InvariantCulture);
                            paginationTcs.TrySetResult(checked((int)totalCount));
                        }
                        else
                        {
                            paginationTcs.TrySetResult(0);
                        }
                    }
                    finally
                    {
                        if (!paginationTcs.Task.IsCompleted)
                        {
                            if (ct.IsCancellationRequested)
                            {
                                paginationTcs.TrySetCanceled(ct);
                            }
                            else
                            {
                                paginationTcs.TrySetException(
                                    new InvalidOperationException("Pagination metadata could not be resolved."));
                            }
                        }
                    }
                }
            }
        }

        return AsyncPagedEnumerable.Create(
            ReadPagedAsync(cancellationToken),
            async ct =>
            {
                if (!paginationTcs.Task.IsCompleted)
                {
                    var count = await CountAsync(specification, ct).ConfigureAwait(false);
                    paginationTcs.TrySetResult(checked((int)count));
                }

                var totalCount = await paginationTcs.Task.WaitAsync(ct).ConfigureAwait(false);
                var pageSize = specification.Take ?? totalCount;
                var currentPage = pageSize > 0 && specification.Skip.HasValue
                    ? (specification.Skip.Value / pageSize) + 1
                    : pageSize > 0 ? 1 : 0;

                return Pagination.Create(
                    pageSize: pageSize,
                    currentPage: currentPage,
                    totalCount: totalCount);
            });

        static List<SqlParameter> MergeParameters(IReadOnlyList<SqlParameter> first, IReadOnlyList<SqlParameter> second)
        {
            var merged = new Dictionary<string, SqlParameter>(StringComparer.OrdinalIgnoreCase);

            foreach (var param in first)
            {
                merged[param.Name] = param;
            }

            foreach (var param in second)
            {
                merged.TryAdd(param.Name, param);
            }

            return [.. merged.Values];
        }
    }

    /// <inheritdoc />
    public virtual async Task<TResult> QuerySingleAsync<TResult>(
        IDataSpecification<TData, TResult> specification,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        ArgumentNullException.ThrowIfNull(specification);

        TResult? first = default;
        var count = 0;

        await foreach (var result in QueryAsync(specification, cancellationToken).ConfigureAwait(false))
        {
            count++;
            if (count == 1)
            {
                first = result;
            }
            else
            {
                throw new InvalidOperationException("Sequence contains more than one element.");
            }
        }

        return count == 0
            ? throw new InvalidOperationException("Sequence contains no elements.")
            : first!;
    }

    /// <inheritdoc />
    public virtual async Task<TResult?> QuerySingleOrDefaultAsync<TResult>(
        IDataSpecification<TData, TResult> specification,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        ArgumentNullException.ThrowIfNull(specification);

        TResult? first = default;
        var count = 0;

        await foreach (var result in QueryAsync(specification, cancellationToken).ConfigureAwait(false))
        {
            count++;
            if (count == 1)
            {
                first = result;
            }
            else
            {
                throw new InvalidOperationException("Sequence contains more than one element.");
            }
        }

        return count == 0 ? default : first;
    }

    /// <inheritdoc />
    public virtual async Task<TResult> QueryFirstAsync<TResult>(
        IDataSpecification<TData, TResult> specification,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        ArgumentNullException.ThrowIfNull(specification);

        await foreach (var result in QueryAsync(specification, cancellationToken).ConfigureAwait(false))
        {
            return result;
        }

        throw new InvalidOperationException("Sequence contains no elements.");
    }

    /// <inheritdoc />
    public virtual async Task<TResult?> QueryFirstOrDefaultAsync<TResult>(
        IDataSpecification<TData, TResult> specification,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        ArgumentNullException.ThrowIfNull(specification);

        await foreach (var result in QueryAsync(specification, cancellationToken).ConfigureAwait(false))
        {
            return result;
        }

        return default;
    }

    /// <inheritdoc />
    public virtual async Task<long> CountAsync<TResult>(
        IDataSpecification<TData, TResult> specification,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        ArgumentNullException.ThrowIfNull(specification);

        var queryResult = _sqlBuilder.BuildCount(specification);
        var context = new DataCommandContext(queryResult.Sql, queryResult.Parameters, DataCommandOperationType.Scalar, _entityTypeName);

        var command = _connectionScope.CreateCommand(queryResult);
        await using (command.ConfigureAwait(false))
        {
            var result = await ExecuteScalarInterceptedAsync(command, context, cancellationToken).ConfigureAwait(false);
            return Convert.ToInt64(result, CultureInfo.InvariantCulture);
        }
    }

    /// <inheritdoc />
    public virtual async Task<bool> ExistsAsync<TResult>(
        IDataSpecification<TData, TResult> specification,
        CancellationToken cancellationToken = default)
    {
        var count = await CountAsync(specification, cancellationToken).ConfigureAwait(false);
        return count > 0;
    }

    /// <inheritdoc />
    [UnconditionalSuppressMessage("Trimming", "IL2091:Target generic argument does not have matching annotations",
        Justification = "TResult is expected to have public properties and parameterless constructor for mapping.")]
    public virtual async IAsyncEnumerable<TResult> QueryRawAsync<TResult>(
        string sql,
        IEnumerable<SqlParameter>? parameters = null,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        ArgumentException.ThrowIfNullOrWhiteSpace(sql);

        var paramList = parameters as IReadOnlyList<SqlParameter> ?? [.. (parameters ?? [])];
        var context = new DataCommandContext(sql, paramList, DataCommandOperationType.Reader, _entityTypeName);

        var command = _connectionScope.CreateCommand();
        command.CommandText = sql;

        foreach (var param in paramList)
        {
            var dbParam = command.CreateParameter();
            dbParam.ParameterName = param.Name;
            dbParam.Value = param.Value ?? DBNull.Value;
            command.Parameters.Add(dbParam);
        }

        await using (command.ConfigureAwait(false))
        {
            var reader = await ExecuteReaderInterceptedAsync(command, context, cancellationToken)
                .ConfigureAwait(false);

            await using (reader.ConfigureAwait(false))
            {
                while (await reader.ReadAsync(cancellationToken).ConfigureAwait(false))
                {
                    yield return _sqlMapper.MapToResult<TResult>(reader);
                }
            }
        }
    }

    /// <inheritdoc />
    public virtual async Task<int> ExecuteAsync(
        string sql,
        IEnumerable<SqlParameter>? parameters = null,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        ArgumentException.ThrowIfNullOrWhiteSpace(sql);

        var paramList = parameters as IReadOnlyList<SqlParameter> ?? [.. (parameters ?? [])];
        var context = new DataCommandContext(sql, paramList, DataCommandOperationType.NonQuery, _entityTypeName);

        var command = _connectionScope.CreateCommand();
        command.CommandText = sql;

        foreach (var param in paramList)
        {
            var dbParam = command.CreateParameter();
            dbParam.ParameterName = param.Name;
            dbParam.Value = param.Value ?? DBNull.Value;
            command.Parameters.Add(dbParam);
        }

        await using (command.ConfigureAwait(false))
        {
            return await ExecuteNonQueryInterceptedAsync(command, context, cancellationToken).ConfigureAwait(false);
        }
    }

    /// <inheritdoc />
    public virtual async Task<int> InsertAsync(
        TData data,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        ArgumentNullException.ThrowIfNull(data);

        var queryResult = _sqlBuilder.BuildInsert(data);
        var context = new DataCommandContext(queryResult.Sql, queryResult.Parameters, DataCommandOperationType.NonQuery, _entityTypeName);

        var command = _connectionScope.CreateCommand(queryResult);
        await using (command.ConfigureAwait(false))
        {
            return await ExecuteNonQueryInterceptedAsync(command, context, cancellationToken).ConfigureAwait(false);
        }
    }

    /// <inheritdoc />
    public virtual async Task<int> InsertAsync(
        IEnumerable<TData> entities,
            CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        ArgumentNullException.ThrowIfNull(entities);

        var dataList = entities.ToList();
        if (dataList.Count == 0)
            return 0;

        var queryResult = _sqlBuilder.BuildInsertBatch(dataList);

        if (string.IsNullOrEmpty(queryResult.Sql))
            return 0;

        var context = new DataCommandContext(queryResult.Sql, queryResult.Parameters, DataCommandOperationType.NonQuery, _entityTypeName);

        var command = _connectionScope.CreateCommand(queryResult);
        await using (command.ConfigureAwait(false))
        {
            return await ExecuteNonQueryInterceptedAsync(command, context, cancellationToken).ConfigureAwait(false);
        }
    }

    /// <inheritdoc />
    public virtual async Task<int> UpdateAsync(
        IDataSpecification<TData, TData> specification,
        DataUpdater<TData> updater,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        ArgumentNullException.ThrowIfNull(specification);
        ArgumentNullException.ThrowIfNull(updater);

        if (updater.Updates.Count == 0)
            throw new InvalidOperationException("The updater must contain at least one property update.");

        var queryResult = _sqlBuilder.BuildUpdate(specification, updater);
        var context = new DataCommandContext(queryResult.Sql, queryResult.Parameters, DataCommandOperationType.NonQuery, _entityTypeName);

        var command = _connectionScope.CreateCommand(queryResult);
        await using (command.ConfigureAwait(false))
        {
            return await ExecuteNonQueryInterceptedAsync(command, context, cancellationToken).ConfigureAwait(false);
        }
    }

    /// <inheritdoc />
    public virtual async Task<int> DeleteAsync(
        IDataSpecification<TData, TData> specification,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        ArgumentNullException.ThrowIfNull(specification);

        var queryResult = _sqlBuilder.BuildDelete(specification);
        var context = new DataCommandContext(queryResult.Sql, queryResult.Parameters, DataCommandOperationType.NonQuery, _entityTypeName);

        var command = _connectionScope.CreateCommand(queryResult);
        await using (command.ConfigureAwait(false))
        {
            return await ExecuteNonQueryInterceptedAsync(command, context, cancellationToken).ConfigureAwait(false);
        }
    }

    private async ValueTask<Common.DbDataReader> ExecuteReaderInterceptedAsync(
        Common.DbCommand command,
        DataCommandContext context,
        CancellationToken cancellationToken)
    {
        await _interceptor.CommandExecutingAsync(context, cancellationToken).ConfigureAwait(false);

        var startTimestamp = Stopwatch.GetTimestamp();
        try
        {
            var reader = await command.ExecuteReaderAsync(cancellationToken).ConfigureAwait(false);
            var duration = Stopwatch.GetElapsedTime(startTimestamp);
            await _interceptor.CommandExecutedAsync(context, duration, null, cancellationToken).ConfigureAwait(false);
            return reader;
        }
        catch (Exception ex)
        {
            var duration = Stopwatch.GetElapsedTime(startTimestamp);
            await _interceptor.CommandFailedAsync(context, duration, ex, cancellationToken).ConfigureAwait(false);
            throw;
        }
    }

    private async ValueTask<object?> ExecuteScalarInterceptedAsync(
        Common.DbCommand command,
        DataCommandContext context,
        CancellationToken cancellationToken)
    {
        await _interceptor.CommandExecutingAsync(context, cancellationToken).ConfigureAwait(false);

        var startTimestamp = Stopwatch.GetTimestamp();
        try
        {
            var result = await command.ExecuteScalarAsync(cancellationToken).ConfigureAwait(false);
            var duration = Stopwatch.GetElapsedTime(startTimestamp);
            await _interceptor.CommandExecutedAsync(context, duration, null, cancellationToken).ConfigureAwait(false);
            return result;
        }
        catch (Exception ex)
        {
            var duration = Stopwatch.GetElapsedTime(startTimestamp);
            await _interceptor.CommandFailedAsync(context, duration, ex, cancellationToken).ConfigureAwait(false);
            throw;
        }
    }

    private async ValueTask<int> ExecuteNonQueryInterceptedAsync(
        Common.DbCommand command,
        DataCommandContext context,
        CancellationToken cancellationToken)
    {
        await _interceptor.CommandExecutingAsync(context, cancellationToken).ConfigureAwait(false);

        var startTimestamp = Stopwatch.GetTimestamp();
        try
        {
            var rowsAffected = await command.ExecuteNonQueryAsync(cancellationToken).ConfigureAwait(false);
            var duration = Stopwatch.GetElapsedTime(startTimestamp);
            await _interceptor.CommandExecutedAsync(context, duration, rowsAffected, cancellationToken).ConfigureAwait(false);
            return rowsAffected;
        }
        catch (Exception ex)
        {
            var duration = Stopwatch.GetElapsedTime(startTimestamp);
            await _interceptor.CommandFailedAsync(context, duration, ex, cancellationToken).ConfigureAwait(false);
            throw;
        }
    }

    /// <summary>
    /// Throws if the repository has been disposed.
    /// </summary>
    protected void ThrowIfDisposed()
    {
        ObjectDisposedException.ThrowIf(_isDisposed, this);
    }

    /// <inheritdoc />
    public void Dispose()
    {
        if (_isDisposed)
            return;

        _isDisposed = true;
        // Connection is owned by the unit of work, not disposed here
        GC.SuppressFinalize(this);
    }

    /// <inheritdoc />
    public ValueTask DisposeAsync()
    {
        if (_isDisposed)
            return ValueTask.CompletedTask;

        _isDisposed = true;
        // Connection is owned by the unit of work, not disposed here
        GC.SuppressFinalize(this);
        return ValueTask.CompletedTask;
    }
}
