/*******************************************************************************
 * Copyright (C) 2025 Kamersoft
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
********************************************************************************/
using System.Data.Common;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Reflection;
using System.Runtime.CompilerServices;

namespace System.Entities.Data;

/// <summary>
/// Provides an ADO.NET implementation of <see cref="IDataRepository{TEntity}"/>.
/// </summary>
/// <remarks>
/// <para>
/// This implementation uses <see cref="ISqlBuilder"/> to generate SQL queries from
/// <see cref="IQuerySpecification{TEntity, TResult}"/> and executes them using ADO.NET.
/// </para>
/// <para>
/// All operations are executed immediately against the database. For transactional
/// operations, use the repository within an <see cref="IDataUnitOfWork"/> with an active transaction.
/// </para>
/// </remarks>
/// <typeparam name="TEntity">The entity type.</typeparam>
#pragma warning disable CA1063 // Implement IDisposable correctly - simplified for sealed-like behavior
#pragma warning disable CA2100 // Review SQL queries for security vulnerabilities - SQL is generated by ISqlBuilder with parameters
[RequiresDynamicCode("Expression compilation requires dynamic code generation.")]
public class DataRepository<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)] TEntity>
    : IDataRepository<TEntity>
    where TEntity : class
{
    private readonly IDbConnectionScope _connectionScope;
    private readonly ISqlBuilder _sqlBuilder;
    private bool _isDisposed;

    /// <summary>
    /// Initializes a new instance of the <see cref="DataRepository{TEntity}"/> class.
    /// </summary>
    /// <param name="connectionScope">The connection scope to use for database operations.</param>
    /// <param name="sqlBuilder">The SQL builder for generating queries.</param>
    public DataRepository(IDbConnectionScope connectionScope, ISqlBuilder sqlBuilder)
    {
        _connectionScope = connectionScope ?? throw new ArgumentNullException(nameof(connectionScope));
        _sqlBuilder = sqlBuilder ?? throw new ArgumentNullException(nameof(sqlBuilder));
    }

    /// <inheritdoc />
    [UnconditionalSuppressMessage("Trimming", "IL2091:Target generic argument does not have matching annotations",
        Justification = "TResult is expected to have public properties and parameterless constructor for mapping.")]
    public virtual async IAsyncEnumerable<TResult> QueryAsync<TResult>(
        IQuerySpecification<TEntity, TResult> specification,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        ArgumentNullException.ThrowIfNull(specification);

        var queryResult = _sqlBuilder.BuildSelect(specification);

        var command = CreateCommand(queryResult);
        await using (command.ConfigureAwait(false))
        {
            var reader = await command
                .ExecuteReaderAsync(cancellationToken)
                .ConfigureAwait(false);

            await using (reader.ConfigureAwait(false))
            {
                while (await reader.ReadAsync(cancellationToken).ConfigureAwait(false))
                {
                    yield return MapToResult<TResult>(reader);
                }
            }
        }
    }

    /// <inheritdoc/>
    public virtual IAsyncPagedEnumerable<TResult> QueryPagedAsync<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties | DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)] TResult>(
        IQuerySpecification<TEntity, TResult> specification,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        ArgumentNullException.ThrowIfNull(specification);
        var selectResult = _sqlBuilder.BuildSelect(specification);
        var countResult = _sqlBuilder.BuildCount(specification);
        var paginationTcs = new TaskCompletionSource<int>(TaskCreationOptions.RunContinuationsAsynchronously);

        async IAsyncEnumerable<TResult> ReadPagedAsync(
            [EnumeratorCancellation] CancellationToken ct = default)
        {
            var command = _connectionScope.CreateCommand();
            command.CommandText = $"{selectResult.Sql};{countResult.Sql}";

            foreach (var param in MergeParameters(selectResult.Parameters, countResult.Parameters))
            {
                var dbParam = command.CreateParameter();
                dbParam.ParameterName = param.Name;
                dbParam.Value = param.Value ?? DBNull.Value;
                command.Parameters.Add(dbParam);
            }

            await using (command.ConfigureAwait(false))
            {
                var reader = await command.ExecuteReaderAsync(ct).ConfigureAwait(false);
                await using (reader.ConfigureAwait(false))
                {
                    try
                    {
                        while (await reader.ReadAsync(ct).ConfigureAwait(false))
                        {
                            yield return MapToResult<TResult>(reader);
                        }

                        if (await reader.NextResultAsync(ct).ConfigureAwait(false) &&
                            await reader.ReadAsync(ct).ConfigureAwait(false))
                        {
                            var totalCount = Convert.ToInt64(reader.GetValue(0), CultureInfo.InvariantCulture);
                            paginationTcs.TrySetResult(checked((int)totalCount));
                        }
                        else
                        {
                            paginationTcs.TrySetResult(0);
                        }
                    }
                    finally
                    {
                        if (!paginationTcs.Task.IsCompleted)
                        {
                            if (ct.IsCancellationRequested)
                            {
                                paginationTcs.TrySetCanceled(ct);
                            }
                            else
                            {
                                paginationTcs.TrySetException(
                                    new InvalidOperationException("Pagination metadata could not be resolved."));
                            }
                        }
                    }
                }
            }
        }

        return AsyncPagedEnumerable.Create(
            ReadPagedAsync(cancellationToken),
            async ct =>
            {
                if (!paginationTcs.Task.IsCompleted)
                {
                    var count = await CountAsync(specification, ct).ConfigureAwait(false);
                    paginationTcs.TrySetResult(checked((int)count));
                }

                var totalCount = await paginationTcs.Task.WaitAsync(ct).ConfigureAwait(false);
                var pageSize = specification.Take ?? totalCount;
                var currentPage = pageSize > 0 && specification.Skip.HasValue
                    ? (specification.Skip.Value / pageSize) + 1
                    : pageSize > 0 ? 1 : 0;

                return Pagination.Create(
                    pageSize: pageSize,
                    currentPage: currentPage,
                    totalCount: totalCount);
            });

        static IEnumerable<SqlParameter> MergeParameters(
            IReadOnlyList<SqlParameter> first,
            IReadOnlyList<SqlParameter> second)
        {
            var merged = new Dictionary<string, SqlParameter>(StringComparer.OrdinalIgnoreCase);

            foreach (var param in first)
            {
                merged[param.Name] = param;
            }

            foreach (var param in second)
            {
                merged.TryAdd(param.Name, param);
            }

            return merged.Values;
        }
    }

    /// <inheritdoc />
    public virtual async Task<TResult> QuerySingleAsync<TResult>(
        IQuerySpecification<TEntity, TResult> specification,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        ArgumentNullException.ThrowIfNull(specification);

        var results = await QueryToListAsync(specification, cancellationToken).ConfigureAwait(false);

        return results.Count switch
        {
            0 => throw new InvalidOperationException("Sequence contains no elements."),
            1 => results[0],
            _ => throw new InvalidOperationException("Sequence contains more than one element.")
        };
    }

    /// <inheritdoc />
    public virtual async Task<TResult?> QuerySingleOrDefaultAsync<TResult>(
        IQuerySpecification<TEntity, TResult> specification,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        ArgumentNullException.ThrowIfNull(specification);

        var results = await QueryToListAsync(specification, cancellationToken).ConfigureAwait(false);

        return results.Count switch
        {
            0 => default,
            1 => results[0],
            _ => throw new InvalidOperationException("Sequence contains more than one element.")
        };
    }

    /// <inheritdoc />
    public virtual async Task<TResult> QueryFirstAsync<TResult>(
        IQuerySpecification<TEntity, TResult> specification,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        ArgumentNullException.ThrowIfNull(specification);

        await foreach (var result in QueryAsync<TResult>(specification, cancellationToken).ConfigureAwait(false))
        {
            return result;
        }

        throw new InvalidOperationException("Sequence contains no elements.");
    }

    /// <inheritdoc />
    public virtual async Task<TResult?> QueryFirstOrDefaultAsync<TResult>(
        IQuerySpecification<TEntity, TResult> specification,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        ArgumentNullException.ThrowIfNull(specification);

        await foreach (var result in QueryAsync<TResult>(specification, cancellationToken).ConfigureAwait(false))
        {
            return result;
        }

        return default;
    }

    /// <inheritdoc />
    public virtual async Task<long> CountAsync<TResult>(
        IQuerySpecification<TEntity, TResult> specification,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        ArgumentNullException.ThrowIfNull(specification);

        var queryResult = _sqlBuilder.BuildCount(specification);

        var command = CreateCommand(queryResult);
        await using (command.ConfigureAwait(false))
        {
            var result = await command.ExecuteScalarAsync(cancellationToken).ConfigureAwait(false);
            return Convert.ToInt64(result, CultureInfo.InvariantCulture);
        }
    }

    /// <inheritdoc />
    public virtual async Task<bool> ExistsAsync<TResult>(
        IQuerySpecification<TEntity, TResult> specification,
        CancellationToken cancellationToken = default)
    {
        var count = await CountAsync(specification, cancellationToken).ConfigureAwait(false);
        return count > 0;
    }

    /// <inheritdoc />
    [UnconditionalSuppressMessage("Trimming", "IL2091:Target generic argument does not have matching annotations",
        Justification = "TResult is expected to have public properties and parameterless constructor for mapping.")]
    public virtual async IAsyncEnumerable<TResult> QueryRawAsync<TResult>(
        string sql,
        IEnumerable<SqlParameter>? parameters = null,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        ArgumentException.ThrowIfNullOrWhiteSpace(sql);

        var command = _connectionScope.CreateCommand();
        command.CommandText = sql;

        if (parameters != null)
        {
            foreach (var param in parameters)
            {
                var dbParam = command.CreateParameter();
                dbParam.ParameterName = param.Name;
                dbParam.Value = param.Value ?? DBNull.Value;
                command.Parameters.Add(dbParam);
            }
        }

        await using (command.ConfigureAwait(false))
        {
            var reader = await command
                .ExecuteReaderAsync(cancellationToken)
                .ConfigureAwait(false);

            await using (reader.ConfigureAwait(false))
            {
                while (await reader.ReadAsync(cancellationToken).ConfigureAwait(false))
                {
                    yield return MapToResult<TResult>(reader);
                }
            }
        }
    }

    /// <inheritdoc />
    public virtual async Task<int> ExecuteAsync(
        string sql,
        IEnumerable<SqlParameter>? parameters = null,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        ArgumentException.ThrowIfNullOrWhiteSpace(sql);

        var command = _connectionScope.CreateCommand();
        command.CommandText = sql;

        if (parameters != null)
        {
            foreach (var param in parameters)
            {
                var dbParam = command.CreateParameter();
                dbParam.ParameterName = param.Name;
                dbParam.Value = param.Value ?? DBNull.Value;
                command.Parameters.Add(dbParam);
            }
        }

        await using (command.ConfigureAwait(false))
        {
            return await command.ExecuteNonQueryAsync(cancellationToken).ConfigureAwait(false);
        }
    }

    /// <inheritdoc />
    public virtual async Task<int> InsertAsync(
        TEntity entity,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        ArgumentNullException.ThrowIfNull(entity);

        var queryResult = _sqlBuilder.BuildInsert(entity);

        var command = CreateCommand(queryResult);
        await using (command.ConfigureAwait(false))
        {
            return await command.ExecuteNonQueryAsync(cancellationToken).ConfigureAwait(false);
        }
    }

    /// <inheritdoc />
    public virtual async Task<int> InsertAsync(
        IEnumerable<TEntity> entities,
            CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        ArgumentNullException.ThrowIfNull(entities);

        var entityList = entities.ToList();
        if (entityList.Count == 0)
            return 0;

        var queryResult = _sqlBuilder.BuildInsertBatch(entityList);

        if (string.IsNullOrEmpty(queryResult.Sql))
            return 0;

        var command = CreateCommand(queryResult);
        await using (command.ConfigureAwait(false))
        {
            return await command.ExecuteNonQueryAsync(cancellationToken).ConfigureAwait(false);
        }
    }

    /// <inheritdoc />
    public virtual async Task<int> UpdateAsync(
        IQuerySpecification<TEntity, TEntity> specification,
        EntityUpdater<TEntity> updater,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        ArgumentNullException.ThrowIfNull(specification);
        ArgumentNullException.ThrowIfNull(updater);

        if (updater.Updates.Count == 0)
            throw new InvalidOperationException("The updater must contain at least one property update.");

        var queryResult = _sqlBuilder.BuildUpdate(specification, updater);

        var command = CreateCommand(queryResult);
        await using (command.ConfigureAwait(false))
        {
            return await command.ExecuteNonQueryAsync(cancellationToken).ConfigureAwait(false);
        }
    }

    /// <inheritdoc />
    public virtual async Task<int> DeleteAsync(
        IQuerySpecification<TEntity, TEntity> specification,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        ArgumentNullException.ThrowIfNull(specification);

        var queryResult = _sqlBuilder.BuildDelete(specification);

        var command = CreateCommand(queryResult);
        await using (command.ConfigureAwait(false))
        {
            return await command.ExecuteNonQueryAsync(cancellationToken).ConfigureAwait(false);
        }
    }

    /// <summary>
    /// Creates a command from a SQL query result.
    /// </summary>
    protected DbCommand CreateCommand(SqlQueryResult queryResult)
    {
        var command = _connectionScope.CreateCommand();
        command.CommandText = queryResult.Sql;
        queryResult.ApplyParameters(command);
        return command;
    }

    /// <summary>
    /// Maps a data reader row to a result type.
    /// </summary>
    [UnconditionalSuppressMessage("Trimming", "IL2072:Target parameter argument does not satisfy 'DynamicallyAccessedMembersAttribute'",
        Justification = "TResult is constrained to have public properties.")]
    [UnconditionalSuppressMessage("Trimming", "IL2091:Target generic argument does not have matching annotations",
        Justification = "TResult types are expected to have public parameterless constructors.")]
    [UnconditionalSuppressMessage("Trimming", "IL2090:Target argument does not satisfy DynamicallyAccessedMembersAttribute",
        Justification = "TResult types are expected to have public properties.")]
    protected virtual TResult MapToResult<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties | DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)] TResult>(DbDataReader reader)
    {
        ArgumentNullException.ThrowIfNull(reader);

        var resultType = typeof(TResult);

        // Handle primitive types and strings
        if (resultType.IsPrimitive || resultType == typeof(string) || resultType == typeof(Guid) ||
            resultType == typeof(DateTime) || resultType == typeof(decimal))
        {
            var value = reader.GetValue(0);
            if (value == DBNull.Value)
            {
                return default!;
            }
            return (TResult)Convert.ChangeType(value, resultType, CultureInfo.InvariantCulture);
        }

        // Handle nullable types
        var underlyingType = Nullable.GetUnderlyingType(resultType);
        if (underlyingType != null)
        {
            var value = reader.GetValue(0);
            if (value == DBNull.Value)
                return default!;
            return (TResult)Convert.ChangeType(value, underlyingType, CultureInfo.InvariantCulture);
        }

        // Handle complex types - map by property name
        var instance = Activator.CreateInstance<TResult>();
        var properties = resultType.GetProperties(BindingFlags.Public | BindingFlags.Instance);

        for (var i = 0; i < reader.FieldCount; i++)
        {
            var columnName = reader.GetName(i);
            var property = FindProperty(properties, columnName);

            if (property != null && property.CanWrite)
            {
                var value = reader.GetValue(i);
                if (value != DBNull.Value)
                {
                    var convertedValue = ConvertValue(value, property.PropertyType);
                    property.SetValue(instance, convertedValue);
                }
            }
        }

        return instance;
    }

    /// <summary>
    /// Finds a property matching the column name.
    /// </summary>
    private static PropertyInfo? FindProperty(PropertyInfo[] properties, string columnName)
    {
        // Exact match first
        foreach (var prop in properties)
        {
            if (string.Equals(prop.Name, columnName, StringComparison.OrdinalIgnoreCase))
                return prop;
        }
        return null;
    }

    /// <summary>
    /// Converts a database value to the target property type.
    /// </summary>
    private static object? ConvertValue(object value, Type targetType)
    {
        if (value == DBNull.Value)
            return null;

        var underlyingType = Nullable.GetUnderlyingType(targetType) ?? targetType;

        if (underlyingType == typeof(Guid) && value is string guidString)
            return Guid.Parse(guidString);

        if (underlyingType.IsEnum)
            return Enum.ToObject(underlyingType, value);

        if (targetType == typeof(Text.Json.JsonDocument) && value is string jsonString)
        {
            return Text.Json.JsonDocument.Parse(jsonString);
        }

        return Convert.ChangeType(value, underlyingType, CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// Queries to a list for operations that need materialization.
    /// </summary>
    private async Task<List<TResult>> QueryToListAsync<TResult>(
        IQuerySpecification<TEntity, TResult> specification,
        CancellationToken cancellationToken)
    {
        var results = new List<TResult>();
        await foreach (var result in QueryAsync<TResult>(specification, cancellationToken).ConfigureAwait(false))
        {
            results.Add(result);
        }
        return results;
    }

    /// <summary>
    /// Throws if the repository has been disposed.
    /// </summary>
    protected void ThrowIfDisposed()
    {
        ObjectDisposedException.ThrowIf(_isDisposed, this);
    }

    /// <inheritdoc />
    public void Dispose()
    {
        if (_isDisposed)
            return;

        _isDisposed = true;
        // Connection is owned by the unit of work, not disposed here
        GC.SuppressFinalize(this);
    }

    /// <inheritdoc />
    public ValueTask DisposeAsync()
    {
        if (_isDisposed)
            return ValueTask.CompletedTask;

        _isDisposed = true;
        // Connection is owned by the unit of work, not disposed here
        GC.SuppressFinalize(this);
        return ValueTask.CompletedTask;
    }
}